# Hyperledger Fabric :  A Distributed Operating System for Permissioned Blockchains

原文：https://arxiv.org/pdf/1801.10228.pdf  
作者：Elli Androulaki Artem Barger Vita Bortnikov Christian Cachin Konstantinos Christidis Angelo De Caro David Enyeart Christopher Ferris Gennady Laventman Yacov Manevich Srinivasan Muralidharan∗ Chet Murthy† Binh Nguyen ∗ Manish Sethi Gari Singh Keith Smith Alessandro Sorniotti Chrysoula Stathakopoulou Marko Vukoli´c Sharon Weed Cocco Jason Yellick I B M  
翻译：Vayne Tian  
  
## 摘要
Hyperledger Fabric是一个用来部署和操作拥有准入机制的区块链的模块化可扩展的开源系统。Fabric目前已经被应用在超过400种跨行业的生产系统和分布式账本技术的原型与概念实现中。  

让我们假设没有一种可以一劳永逸的解决方案，那Fabric就是第一个可扩展的运行分布式程序的区块链系统。它支持通过模块化的共识算法定制特定的使用场景和信任模型。Fabric还是第一个没有对原生加密货币有系统依赖性，并应用通用编程语言编写分布式程序的区块链。这和一些现在的主流区块链平台形成了鲜明对比，这些平台要么依赖于特定领域语言编写的智能合约，要么依赖于加密货币。此外，它还使用便携的成员资格的概念实现了一个准入模型，这将可能会与身份管理系统的行业标准结合。为了支持这种灵活性，Fabric用一种新奇的方式实现了拥有准入机制的区块链设计，并且改变了区块链处理不确定性、资源枯竭和性能攻击的问题。  

这篇文章描述了Fabric的架构，它的各种设计决定背后的原理，它的安全模型与保障，以及最显著的实现特征，和它的分布式系统编程模型。  

我们对Fabric进行了更深层次的评估，实现和测试一个比特币类的数字货币。结果显示，亚秒级延迟的情况下，在一个特定的合约部署中，Fabric实现了每秒超过3500个端到端交易的量级。

## 1.简介

区块链可以被如此定义：它是一个不可变账本，记录交易历史，维护一个毋须信任节点间的分布式网络。每个节点维护一个账本的副本。这个节点执行共识算法来验证交易，把他们分组进区块，并根据区块信息生成一个哈希链。这个过程将会给交易排序，这对于保证连续性和一致性是十分必要的。区块链已经从比特币的名号中脱颖而出，并被广泛的认为是一种有前景的在数字世界中进行信任交流的技术。  
在一个公有的没有准入机制的区块链中，任何一个没有特定身份的人都可以参与进来。公有链常常需要原生的加密货币，工作量证明作为共识算法和经济利益。  
从另一方面来讲，拥有准入机制的区块链中，在一系列已知身份的节点中运行区块链。它可以通过在一组毋须信任对方但有相同目的的的实体中保证安全性，就像在商业中进行基金、信息和商品的交换（都为了追求利益，而不需要信任对方）。由于节点身份已知，拥有准入机制的区块链可以使用传统的拜占庭容错作为共识算法。  

区块链在智能合约（例如以太坊的实现）的帮助下，可以实现任意可编程的交易逻辑。比特币中的脚本是合约的前身。一个智能合约可以像一个可信分布式应用一样运作,通过区块链和节点间的共识算法获取安全性。这与知名的通过状态机副本建立应用的方式十分类似。然而，使用拜占庭容错算法的区块链技术与传统的状态机副本区别如下：  
1.多个而不是只有一个分布式应用在并行运行。  
2.应用可以被任何人动态的创建部署。  
3.应用的代码是不受信任的甚至恶意的。  
这些特性需要新的设计来实现。

目前实现智能合约的区块链很多是基于状态机复制的蓝图，实现了所谓的活跃副本：  
1.共识算法，或是原子广播，首先对交易进行排列，然后把他们按排列广播给所有节点  
2.每个节点按照排序-执行进行交易  

我们把这个叫做排序-执行架构，它要求节点要执行每一个交易，并且所有的交易都是确定的。这种排序-执行架构可以在几乎所有现存的区块链中找到，无论是公有链，比如基于工作量证明的以太坊（存疑，原文如此，以太坊使用的是权益证明），或者是有准入机制的使用拜占庭容错算法的区块链，像Tendermint，Chain，Quorum 。尽管如此，排序-执行的设计并不是使用在所有的系统中，因为额外的交易可能会扰乱它，这种设计的限制是它与生俱来的：每个节点都要执行所有的交易，并且所有的交易必须是确定的。

早先的有准入机制的区块链受到许多限制，这些限制来源于相似的没有准入机制的区块链或是排序-执行架构。尤其是以下部分：  
1.共识机制是在平台中硬编码的（难以修改），这和之前所说的没有一种一劳永逸的（BFT）共识算法相矛盾。  
2.交易验证的信任模型是被共识算法所决定的，而这个模型不适应智能合约的一些要求。 
3.智能合约必须用固定的，不标准的，领域特定语言编写，这阻碍了它被进一步广泛的应用，并且可能导致一些编程错误。  
4.全节点对交易的排序-执行过程会限制性能，并且需要一些复杂的方法去防止对平台发起的拒绝攻击，这种攻击源自非信任的智能合约，比如 accounting for runtime with “gas” in Ethereum（这里还不太了解~）。  
5.交易必须是确定的，但这很难以编程的方式去保证。  
6.每个智能合约都在所有的节点上运行，这和它的保密特性相矛盾，并且拒绝合约代码与总节点的一个子集状态的传播。  

在这篇文章中，我们将会介绍Hyperledger Fabric，一个突破了以上限制的区块链平台。Fabric是Linux基金会支持的超级账本项目下的子项目之一。Fabric已经在超过400种不同行业、不同用途的原型、概念或是分布式账本系统的开发中被使用。

这些用途包括但不仅限于解决争端，物流贸易，外汇网络，食品安全，合同管理，珠宝鉴定，积分管理，低流动性证券的交易和结算，身份管理，数字货币结算等。

Fabric使用了新的区块链架构，具有弹性，灵活性，可扩展性和保密性。作为一种模块化可扩展的带有准入机制的通用区块链，Fabric支持标准通用编程语言编写的分布式应用。这使得Fabric成为拥有准入机制的区块链的第一个分布式操作系统。


为了在不可信的环境中分布式执行不可信任的代码，Fabric遵循一种新的执行顺序验证（execute-order-validate）的范式。它将交易流程分为三个步骤:  
1.执行交易并检查交易的正确性，从而将其合法化。（这与其他区块链中的验证交易环节相对应）  
2.通过共识算法给交易排序，这里不考虑交易的内容。  
3.依照每个应用特定的可信假设进行交易的验证，这解决了由于并行产生的竞争问题。

Fabric的设计与排序-执行范式完全不同，它通常在按照交易顺序达成最终共识前就已经执行了交易。它结合了主动和被动两种手段生成副本。下文将会介绍它们。

首先，Fabric使用被动方式或主服务器备份的副本，这在分布式数据库中很常见，但通过基于中间件的非对称更新过程并移植到存在拜占庭错误的不可信环境中。在Fabric中，依靠“执行验证”拜占庭容错算法的副本，每个合法交易只会在一部分节点中执行，这考虑到了平行执行的情况并解决了潜在的不确定性。这个灵活的背书策略将指定哪些或多少节点需要对这个智能合约的正确执行进行担保。

其次，Fabric还结合了主动复制(active replication)，从这个意义上讲，在每个节点的验证环节，交易对账本状态的改变只有按照它们的全序达成一致后才被写入。这可以让Fabric根据交易背书来遵守指定应用的可信假设。此外，为了达成一致性，状态更新的顺序被委派给了模块化的组件，比如原子广播，这个组件是无状态的，并且与那些执行交易和维持账本的节点逻辑上是解耦的。由于共识是模块化的，因此可以通过一个特定部署的可信假设去定制它。虽然可以通过区块链的节点去实现共识算法，但分开这两个角色可以增加灵活性，并使得它可以直接使用 非拜占庭容错CFT (Crash fault-tolerant) 或 拜占庭容错BFT (Byzantine fault-tolerant) 进行排序的工具包。

综上，这个在拜占庭错误模型下结合了主动复制和被动复制的混合副本设计，以及顺序交易验证的范式，就是Fabric架构的主要创新点。它们解决了之前所说的问题，并使得Fabric成为一个在拥有准入机制的区块链中支持灵活的可信假设的可扩展系统。

为了实现这个架构，Fabric包含了以下组件的模块化基石。

**排序服务**：排序服务向所有节点原子广播状态更新，并在交易顺序上建立共识。Apache Kafka/ZooKeeper 和  BFT-SMaRt 已经实现了排序服务。

**身份与成员资格**：成员资格服务负责通过加密身份将节点联系起来，这项服务使得Fabric拥有准入机制。

**可扩展的传播**：可选的点对点交流服务通过对所有节点的排序服务传播来区块的输出。

**智能合约的执行**：Fabric的智能合约在完全隔离的容器环境中执行。它们可以用通用编程语言编写，但不与账本状态直接产生联系。

**账本维护**：每个节点在本地以键值对的储存形式（KVS）用可追加的区块链来保存账本，并它作为最新状态的快照。可以用标准库实现这个键值对储存，比如LevelDB 或 Apache CouchDB。

文章的剩余部分将详细介绍Fabric的架构以及我们对它的理解。第二节总结了艺术的状态并解释了这些不同设计背后的基础原理。第三节从细节上介绍了Fabric的架构和排序-执行验证的方法，并详细阐述了交易流程。第四节定义了Fabric的关键组件，尤其是排序服务，成员管理服务，点对点交流，账本数据库和智能合约的API。第五节给出了在公开商业化云虚拟机的集群环境下，对Fabric进行使用类比特币的加密货币的性能评估的结果和领悟。结果显示，Fabric在常见的部署配置下，达到了超过3500 tps的吞吐量，算上延迟的情况下在几百毫秒内就可以达成最终共识。最后，在第六节，会讨论一些相关研究。

## 2.背景

### 2.1 区块链的排序-执行架构

无论是否有准入机制，早先的所有区块链系统都遵循排序-执行架构。这意味着区块链网络首先会使用共识算法对交易进行排序，然后在所有节点上按照这个排序线性执行交易。

例如，基于工作量证明的没有准入机制的区块链比如以太坊使用以下方式结合智能合约和交易的执行。

1.每个节点（比如参与合约的节点）收集一个含有有效交易的区块。（为了达到有效，这个节点必须预先执行过这些交易）  
2.这个节点尝试去解决一个工作量证明的数学难题。  
3.如果这个节点解决了数学难题，就会将区块通过传输协议分发到整个网络。  
4.每个节点接收区块并验证数学难题的解以及区块中的所有交易是否合法。实际上，每个节点从第一步开始重复了那个解决谜题的幸运节点的执行内容。此外，所有节点线性执行所有的交易（在一个区块内以及区块间）。这个排序-执行架构如图1所示。


![avatar](https://github.com/Dearkano/Hyperledger-Fabric/blob/master/images/P2F1.png)



现有的拥有准入机制的区块链，比如Tendermint，Chain或是Quorum通常使用了拜占庭容错的一致性，这个一致性是由实用拜占庭容错算法（PBFT）或其他的实现原子广播的协议。然而，他们都遵循同样的排序-执行的方法，并实现了传统的主动状态机副本的架构。

### 2.2 排序-执行的局限性

排序-执行架构从概念上理解很简单，因此被广泛的使用。然而，当将它应用在拥有准入机制的通用区块链中时会有许多缺陷。我们将随后讨论其中最重要的三点。

**线性执行**  
在所有的节点上线性执行交易限制了区块链所能达到的有效吞吐量。特别是由于吞吐量与执行操作的延迟成反比，这可能会成为所有智能合约（即使是最简单的合约）的瓶颈。此外，回想一下与传统的状态机副本（SMR）相比，区块链实现了一个通用的计算引擎，但它的载荷应用可能是被恶意部署的。一个拒绝（DoS)攻击严重降低了区块链的性能，将会直接导致智能合约需要非常久的时间才能执行。例如，一个产生无限循环的智能合约就可以有这样致命的效果，并且由于停机问题的不可解，导致错误很难被自动识别到。  

为了解决这类问题，公有可编程区块链使用加密货币来支付交易费用。例如，以太坊介绍了交易执行中所花费的gas的概念，gas被转换成一定价值的加密货币并由交易的发起者支付。以太坊使用了一个很长的环节去完成这个过程，首先为每一个底层计算步骤分配费用，然后使用自己的虚拟机监视器去控制交易的执行。尽管这看起来是为公有链提供了一个可选的解决方案，然而对于不使用原生加密货币的为通用系统所设计的拥有准入机制的模型来说并不合适。  

**非确定性代码**  
排序-执行架构存在的另一个重要问题是非确定性交易。在主动状态机副本（SMR）的一致性协议中执行的操作必须是确定的，否则分布式账本会产生分叉，会对区块链最基础的前提产生威胁——所有的节点必须保存相同的状态。这个问题通常是由那些使用领域特定语言（比如以太坊的Solidity）编写的区块链解决，这些语言足够编写他们的应用但对于确定性的执行却有局限性。设计这些语言对于实现者来说是非常困难的，并且还要求程序员要额外学习知识去使用这个语言。然而使用通用编程语言（例如Go，Java，C/C++）很明显更加有吸引力，并且能加速区块链解决方案的落地。

不幸的是，通用编程语言在确保确定性操作的执行时产生了很多问题。即使应用开发者不显式使用非确定性的操作，一些隐式实现的细节可能也会导致相同的破坏性的效应（例如，一个地图的迭代器在Go语言中是非确定性的）。尤其糟糕的是，在区块链上创建确定性应用的负担取决于潜在的不可信的程序员。仅仅一个非确定性的被恶意创建的合约已经足以将整个区块链停机。模块化的过滤这种破坏性操作的解决方案已经被研究出来，但很显然这在实际应用中耗费太多。

**操作执行的保密性**  
根据公有链的蓝图，许多拥有准入机制的系统需要在全部的节点上运行智能合约。然而，许多需要准入机制的用途都要求保密性，例如，对智能合约、交易信息或者账本状态的访问应当被限制。然而从数据加密到零知识证明和可验证计算的加密技术可以帮助实现保密性，但这通常会带来非常大的开销，在实际生产中并不可取。

幸运的是，Fabric能满足把相同的状态散布到所有的节点，而不是直接把相同的代码到处运行。因此，智能合约的执行可以被限制在对于这个任务来说可信的节点子集中。这个设计与主动复制不同，它通过不同的被动复制适应了区块链的信任模型。

### 2.3 现存架构的其他局限性

**固定的信任模型**  
大多数拥有准入机制的区块链依赖于异步BFT副本协议去建立共识。这样的协议通常依赖于一个假设：不多于1/3的节点是恶意节点，也就是所谓的拜占庭容错（even though one could actually restrict BFT execution to fewer peers ，待译）。然而，这样一个对恶意节点数量的信任假设，而且不考虑节点在系统中扮演的角色，可能不会匹配智能合约执行时所要求的信任模型。在一个灵活的系统中，应用级别的信任和协议级别的信任不应被固定在同一水平。一个通用的区块链应该解耦这两个前提假设，并且允许在应用上使用灵活的信任模型。

**硬编码的共识算法**  
Fabric是第一个推行可插拔共识算法的区块链系统。在Fabric之前，几乎所有的区块链系统，无论是否拥有准入机制，都使用了硬编码的共识算法。然而，数十年来对共识算法的研究以及证明没有一种一劳永逸的算法可以适应所有场景。例如，BFT算法当被部署在一个潜在的对抗环境中时，性能可能会与相当大的差别。一个拥有链交流特征的协议展示的是它在对称和同质连接的LAN集群经过验证的最佳吞吐量，但这可能会在广泛的应用场景或非同质网络中可能会迅速降低。此外，在一个给定的部署中，一些外部因素，比如负载、网络参数、故障或者攻击随着时间变化可能会是多种多样的。由于以上原因，BFT算法应当原生可重构的，理想情况下，甚至可以动态适应变化的环境。另一个重要的方面是，在一个给定的区块链部署方案中。共识算法可以去匹配算法的信任模型。实际上，一个希望取代BFT的算法以一个可选信任模型为基础，例如XFT，或是CFT协议，像是Pasxs/Raft和ZooKeeper，或是一个毋须准入机制的协议。

### 2.4顺序执行区块链的一些经验
在实现Fabric的排序-执行-验证架构之前，团队从建立在排序-执行模型下，使用PBFT共识算法并拥有准入机制的区块链平台中获取了一些经验。从一些概念上已经得到证明的应用的反馈来说，这种方式的局限性是十分清晰的。例如，用户经常观测节点上发散的节点并提交一些共识机制的漏洞，几乎所有情况下，深入的检测都显示罪魁祸首是那些非确定性的交易代码。其他的一些负面评论则是关于性能的局限性，例如，“一秒怎么只有五个交易被执行”，直到用户发现他们每一个交易平均花费200毫秒去执行。我们已经知道区块链系统的核心属性是一致性、安全性和性能，这些不能依赖于用户的知识或善意，因此区块链应当被运行在一个不可信的环境中。

## 3.架构
在这节中，我们将介绍有三个阶段的排序-执行-验证架构，随后解释交易流程。Fabric组件将会在下一节中讨论。  

### 3.1 Fabric总览
Fabric是一个在拥有准入机制的区块链上执行使用通用编程语言（例如Go，Java，Node.js）编写的分布式应用的分布式操作系统。它没有内置的加密货币，并能通过一个可追加的账本数据副本来安全地追踪交易记录。

基于上一节中提到的原因，Fabric推行排序-执行-验证的区块链架构而不是使用标准的排序-执行的设计。在一个极小的容器中，Fabric的分布式应用包含以下两个部分：
* 智能合约，这里称作链码（chaincode），是一个实现了应用逻辑并在交易执行过程中运行的程序代码。链码是Fabric应用程序的核心部分，它可以被不可信的开发者编写。而那些用作管理区块链系统并维持一些参数的特殊链码，它们被称作系统链码。（4.6节）
* 背书策略，在验证阶段中发挥作用。背书策略不能被那些不可信应用的开发者选择或是修改，这是系统的一部分。背书策略在Fabric的交易验证中扮演静态库的角色，它只能被链码参数化。只有那些指定的管理员可以去运行系统管理函数，或是修改背书策略。

常见的背书策略是让链码以节点集的形式指定一些为这笔交易背书的人，这是背书过程所必需的。它使用集合的一些逻辑上的单调表达式，例如“五个中的三个”或是“A和B 或者 B和C”。自定义的背书策略可以实现任何逻辑，比如比特币类的加密货币。（5.1节）

客户根据背书策略将交易发送给指定的节点。然后交易被这些节点执行并记录结果，这个步骤就称作背书。执行结束后，交易将进入排序阶段，这时将会使用可插拔的共识算法在区块中产生一个所有已验证交易的全序。然后在传输协议的帮助下，它们被广播到所有的节点。与标准的主动副本将全部的交易输入排序不同，Fabric将交易输出和执行阶段产生的状态依赖结合并排序。接着，每个节点将根据背书策略和验证阶段产生的一致性，来验证那些经过背书的交易所产生的状态变化。所有节点将按照同样的顺序去验证交易，验证结果将是确定的。从这个意义上说，Fabric推行了一种新颖的拜占庭模型下的混合副本范式，结合了被动复制（状态更新的预共识计算）和主动复制（执行结果和状态改变的共识后验证）。

这个执行-排序-验证的架构如图2所示。


![avatar](https://github.com/Dearkano/Hyperledger-Fabric/blob/master/images/P2F2.png)



Fabric区块链包含节点集合组成的网络。由于Fabric拥有准入机制，所有的网络中的节点必须拥有身份，这个身份是由一个模块化的成员管理服务（MSP）提供的。Fabric网络中的节点有以下三个身份中的一种：
* **客户**提交交易提案。帮助构建执行阶段，最后为完成排序广播这些交易。
* **节点**执行交易提案并验证交易。同时，节点也负责维持区块链账本（一种可追加的数据结构，以哈希链的形式记录了所有的交易，也记录的世界状态，一种对最新账本状态的简要记录）。并不是所有节点都执行所有的交易，只有一部分被这笔交易所属的背书策略选定的背书节点会这样做。然而，所有的节点在之后必须完成账本的更新。
* **排序服务节点（OSN）**是排序服务中的节点。简而言之，Fabric的排序服务建立起所有交易的全序，每笔交易包含状态的更新和执行过程中计算得到的依赖，还包含那些用于计算的背书节点的加密签名。排序服务节点完全不知道应用的状态，也不参与进交易执行或是交易验证。这样设计是尽可能的将共识算法模块化并简化Fabric中替换共识算法的过程。

由于可以在一台物理节点上运行许多扮演不同角色的节点，Fabric同样可以像传统的点对点区块链系统一样运作（每个节点包含状态、交易调用、交易验证和交易排序）。这个Fabric使用不同类型节点的交易流程如图3所示。


![avatar](https://github.com/Dearkano/Hyperledger-Fabric/blob/master/images/P2F3.png)


与迄今为止那些使用单一区块链的系统相比，Fabric网络实际上可以支持多条区块链连接到同一个排序服务上。每条这样的区块链叫做信道（channel），可能含有不同身份的成员节点。信道可以用来分隔区块链网络的状态，但是信道间的共识算法并不会做出调整，并且不同信道的交易全序也是不同的。对于特定部署而言，假如所有的排序节点都是可信任的，也许可以实现通过信道访问控制节点。下文中我们提到信道时，只会简略地专注于单信道。

下面的三节解释了Fabric的交易流程并阐明了执行、排序、验证的阶段。Fabric网络如图4所示。

### 3.2 执行阶段

在执行阶段中，客户向一个或多个背书节点发送交易提案。回想每个链码都通过背书策略隐式指定了一些背书节点。交易提案包括提交交易的客户身份（通过MSP获得）、执行操作形式的交易负载、参数、链码所有者的标识符、每个节点只用一次的现时标识（例如一个计数器或是一个随机数）和由链码标识符与现时标识生成的交易标识符。同样，客户还会对提案签名。

![avatar](https://github.com/Dearkano/Hyperledger-Fabric/blob/master/images/P2F4.png)

背书节点通过在区块链上预安装的特定链码上执行操作来模拟交易提案。链码通过在Docker容器中运行，与背书进程相隔离。

模拟交易提案是为了在不与其他任何节点同步的情况下改变背书节点的本地区块链状态，此外，背书节点并不保持模拟交易后账本状态的改变。区块链的状态是以版本化控制的键值对形式储存在节点交易管理员（PTM）中的，这里会以单调递增的版本号来记录数据的一次次更新。